<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="googlebot" content="NOODP"><meta name="google-site-verification" content="nSYeDgyKM9mw5CWcZuD0xu7iSWXlJijAlg9rcxVOYf4"><meta name="google-site-verification" content="6UEaC3SWhpGQvqRnSJIEm2swxXpM5Adn4dxZhFsNdw0"><link rel="stylesheet" href="RabbitMQ%20-%20Java%20Client%20API%20Guide_files/rabbit.css" type="text/css"><!--[if IE 6]>
      <link rel="stylesheet" href="/css/rabbit-ie6.css" type="text/css" />
      <![endif]--><link rel="icon" type="/image/vnd.microsoft.icon" href="https://www.rabbitmq.com/favicon.ico"><link rel="stylesheet" href="RabbitMQ%20-%20Java%20Client%20API%20Guide_files/tutorial.css" type="text/css"><script src="RabbitMQ%20-%20Java%20Client%20API%20Guide_files/munchkin.js" async="" type="text/javascript"></script><script src="RabbitMQ%20-%20Java%20Client%20API%20Guide_files/ga.js" async="" type="text/javascript"></script><script type="text/javascript" src="RabbitMQ%20-%20Java%20Client%20API%20Guide_files/site.js"></script><script type="text/javascript" src="RabbitMQ%20-%20Java%20Client%20API%20Guide_files/ga-bootstrap.js"></script><script src="RabbitMQ%20-%20Java%20Client%20API%20Guide_files/munchkin_002.js" async="" type="text/javascript"></script><title>RabbitMQ - Java Client API Guide</title>
        
    <script>try {  for(var lastpass_iter=0; lastpass_iter < document.forms.length; lastpass_iter++){    var lastpass_f = document.forms[lastpass_iter];    if(typeof(lastpass_f.lpsubmitorig)=="undefined"){      if (typeof(lastpass_f.submit) == "function") {        lastpass_f.lpsubmitorig = lastpass_f.submit;        lastpass_f.submit = function(){          var form = this;          try {            if (document.documentElement && 'createEvent' in document)            {              var forms = document.getElementsByTagName('form');              for (var i=0 ; i<forms.length ; ++i)                if (forms[i]==form)                {                  var element = document.createElement('lpformsubmitdataelement');                  element.setAttribute('formnum',i);                  element.setAttribute('from','submithook');                  document.documentElement.appendChild(element);                  var evt = document.createEvent('Events');                  evt.initEvent('lpformsubmit',true,false);                  element.dispatchEvent(evt);                  break;                }            }          } catch (e) {}          try {            form.lpsubmitorig();          } catch (e) {}        }      }    }  }} catch (e) {}</script><script>try {  for(var lastpass_iter=0; lastpass_iter < document.forms.length; lastpass_iter++){    var lastpass_f = document.forms[lastpass_iter];    if(typeof(lastpass_f.lpsubmitorig)=="undefined"){      if (typeof(lastpass_f.submit) == "function") {        lastpass_f.lpsubmitorig = lastpass_f.submit;        lastpass_f.submit = function(){          var form = this;          try {            if (document.documentElement && 'createEvent' in document)            {              var forms = document.getElementsByTagName('form');              for (var i=0 ; i<forms.length ; ++i)                if (forms[i]==form)                {                  var element = document.createElement('lpformsubmitdataelement');                  element.setAttribute('formnum',i);                  element.setAttribute('from','submithook');                  document.documentElement.appendChild(element);                  var evt = document.createEvent('Events');                  evt.initEvent('lpformsubmit',true,false);                  element.dispatchEvent(evt);                  break;                }            }          } catch (e) {}          try {            form.lpsubmitorig();          } catch (e) {}        }      }    }  }} catch (e) {}</script></head>
    <body><div id="outerContainer"><div id="rabbit-logo"><a href="https://www.rabbitmq.com/"><img src="RabbitMQ%20-%20Java%20Client%20API%20Guide_files/rabbitmq_logo_strap.png" alt="RabbitMQ" height="53" width="253"></a></div><div id="pivotal-logo"><a href="http://pivotal.io/"><img src="RabbitMQ%20-%20Java%20Client%20API%20Guide_files/logo-pivotal-118x25.png" alt="Pivotal" height="25" width="118"></a></div><div id="nav-search"><div id="search-box"><form action="/search.html" method="get"><input name="q" size="25" id="search-query" value="Search RabbitMQ" onfocus="handle_SearchBoxFocus();" onblur="handle_SearchBoxBlur();" type="text"><input id="search-button" alt="Search" value="" type="submit"></form></div><ul class="mainNav"><li><a href="https://www.rabbitmq.com/features.html">Features</a></li><li><a href="https://www.rabbitmq.com/download.html">Installation</a></li><li><a href="https://www.rabbitmq.com/documentation.html" class="selected">Docs</a></li><li><a href="https://www.rabbitmq.com/getstarted.html">Tutorials</a></li><li><a href="https://www.rabbitmq.com/services.html">Support</a></li><li><a href="https://www.rabbitmq.com/community.html">Community</a></li><li><a href="http://pivotal.io/careers/engineering">Pivotal is Hiring</a></li><li><a href="https://www.rabbitmq.com/blog/">Blog</a></li></ul></div><div class="nav-separator"></div><div id="left-content"><h1>Java Client API Guide</h1>
        <p class="intro">
            This guide covers RabbitMQ Java client API. It is not, however, a tutorial. Those
            are <a href="https://www.rabbitmq.com/getstarted.html"></a> available in a different section.
        </p>
        <p class="intro">
            The client is triple-licensed under

            </p><ul>
                <li><a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache Public License 2.0</a></li>
                <li><a href="https://www.mozilla.org/MPL/1.1/">Mozilla Public License</a></li>
                <li><a href="http://www.gnu.org/licenses/gpl-2.0.html">GPL 2.0</a></li>
            </ul>
        <p></p>
        <p class="intro">
            For more details, please see the relevant Javadoc <a href="https://www.rabbitmq.com/releases/rabbitmq-java-client/v3.6.3/rabbitmq-java-client-javadoc-3.6.3/">documentation</a>.
        </p>
        <p class="intro">
            The Java client also ships with
            some <a href="https://www.rabbitmq.com/java-tools.html">command line tools</a>.
        </p>

    <p>
        The client API is closely modelled on the AMQP 0-9-1 protocol specification,
        with additional abstractions for ease of use.
    </p>

    <div class="docSection"><a name="classoverview" id="classoverview"></a>
        <h2 class="docHeading">Overview</h2>
        <p>
            RabbitMQ Java client uses <span class="code ">com.rabbitmq.client</span> as its top-level package.
            The key classes and interfaces are:

            </p><ul>
                <li>Channel</li>
                <li>Connection</li>
                <li>ConnectionFactory</li>
                <li>Consumer</li>
            </ul>

            Protocol operations are available through the
            <span class="code ">Channel</span> interface. <span class="code ">Connection</span> is
            used to open channels, register connection lifecycle event
            handlers, and close connections that are no longer needed.
            <span class="code ">Connection</span>s are instantiated through <span class="code ">ConnectionFactory</span>,
            which is how you configure various connection settings, such as the vhost or username.
        <p></p>
    </div>

    <div class="docSection"><a name="connecting" id="connecting"></a>
    <h2 class="docHeading">Connections and Channels</h2>

    <p>
            The core API classes are <span class="code ">Connection</span>
            and <span class="code ">Channel</span>, representing an AMQP 0-9-1 connection and an
            channel, respectively. They are typically imported before used:
    </p>
    <pre class="sourcecode"><b>import</b> com.rabbitmq.client.Connection;
<b>import</b> com.rabbitmq.client.Channel;</pre>

    <h2 class="docHeading">Connecting to a broker</h2>

    <p>
        The following code connects to an AMQP broker using the given parameters (host name, port number, etc):
    </p>

<pre class="sourcecode">ConnectionFactory factory = <b>new</b> ConnectionFactory();
factory.setUsername(<b>userName</b>);
factory.setPassword(<b>password</b>);
factory.setVirtualHost(<b>virtualHost</b>);
factory.setHost(<b>hostName</b>);
factory.setPort(<b>portNumber</b>);
Connection conn = factory.newConnection();
</pre>

    <p>
        All of these parameters have sensible defaults for a RabbitMQ server running locally.
    </p>
    <p>
        Alternatively, <a href="https://www.rabbitmq.com/uri-spec.html">URIs</a> may be used:
    </p>

<pre class="sourcecode">ConnectionFactory factory = <b>new</b> ConnectionFactory();
factory.setUri("<b>amqp://userName:password@hostName:portNumber/virtualHost</b>");
Connection conn = factory.newConnection();
</pre>

    <p>
        All of these parameters have sensible defaults for a stock
        RabbitMQ server running locally.
    </p>

        <p>
        The <span class="code ">Connection</span> interface can then be used to open a channel:
        </p>

<pre class="sourcecode">Channel channel = conn.createChannel();
</pre>
    <p>
        The channel can now be used to send and receive messages, as described in subsequent sections.
    </p>

    <p>
        To disconnect, simply close the channel and the connection:
    </p>

    <pre class="sourcecode">channel.close();
conn.close();</pre>

    <p>
        Note that closing the channel may be considered good practice, but isn’t strictly necessary here - it will be done
        automatically anyway when the underlying connection is closed.
    </p>

  </div>


    <div class="docSection"><a name="exchanges-and-queues" id="exchanges-and-queues"></a>
      <h2 class="docHeading">Using Exchanges and Queues</h2>

      <p>
       Client applications work with exchanges and queues, the high-level building blocks of AMQP.
       These must be "declared" before they can be used. Declaring either type of object
       simply ensures that one of that name exists, creating it if necessary.
      </p>

      <p>
       Continuing the previous example, the following code declares an exchange and a queue,
       then binds them together.
      </p>

      <pre class="sourcecode">channel.exchangeDeclare(<b>exchangeName</b>, <b>"direct"</b>, <b>true</b>);
String <b>queueName</b> = channel.queueDeclare().getQueue();
channel.queueBind(<b>queueName</b>, <b>exchangeName</b>, <b>routingKey</b>);</pre>

      <p>
        This will actively declare the following objects,
        both of which can be customised by using additional parameters.
        Here neither of them have any special arguments.
      </p>

      <ol>
        <li>a durable, non-autodelete exchange of "direct" type</li>
        <li>a non-durable, exclusive, autodelete queue with a generated name</li>
      </ol>

      <p>
        The above function calls then bind the queue to the exchange with the
        given routing key.
      </p>
      <p>
        Note that this would be a typical way to declare a queue when only one
        client wants to work with it: it doesn’t need a well-known name, no
        other client can use it (exclusive) and will be cleaned up
        automatically (autodelete). If several clients want to share a queue
        with a well-known name, this code would be appropriate:
      </p>

      <pre class="sourcecode">channel.exchangeDeclare(<b>exchangeName</b>, <b>"direct"</b>, <b>true</b>);
channel.queueDeclare(<b>queueName</b>, <b>true</b>, <b>false</b>, <b>false</b>, <b>null</b>);
channel.queueBind(<b>queueName</b>, <b>exchangeName</b>, <b>routingKey</b>);</pre>

      <p>
        This will actively declare:
      </p>

      <ol>
        <li>a durable, non-autodelete exchange of "direct" type</li>
        <li>a durable, non-exclusive, non-autodelete queue with a well-known name</li>
      </ol>

      <p>
        Note that all of these <span class="code ">Channel</span> API methods are overloaded.
        These convenient short forms of <span class="code ">exchangeDeclare</span>, <span class="code ">queueDeclare</span> and <span class="code ">queueBind</span>
        use sensible defaults. There are also longer forms with more parameters, to let you override these defaults
        as necessary, giving full control where needed.
      </p>
      <p>
        This "short form, long form" pattern is used throughout the client API uses.
      </p>
    </div>

    <div class="docSection"><a name="publishing" id="publishing"></a>
      <h2 class="docHeading">Publishing messages</h2>

      <p>
        To publish a message to an exchange, use <span class="code ">Channel.basicPublish</span> as follows:
      </p>

      <pre class="sourcecode"><b>byte</b>[] messageBodyBytes = <b>"Hello, world!"</b>.getBytes();
channel.basicPublish(<b>exchangeName</b>, <b>routingKey</b>, <b>null</b>, messageBodyBytes);</pre>

      <p>
        For fine control, you can use overloaded variants to specify the <span class="code ">mandatory</span> flag,
        or send messages with pre-set message properties:
      </p>

      <pre class="sourcecode">channel.basicPublish(<b>exchangeName</b>, <b>routingKey</b>, <b>mandatory</b>,
                     MessageProperties.PERSISTENT_TEXT_PLAIN,
                     messageBodyBytes);</pre>

      <p>
        This sends a message with delivery mode 2 (persistent), priority 1
        and content-type "text/plain". You can build your
        own message properties object, using a <span class="code ">Builder</span> class
        mentioning as many properties as you like, for example:
      </p>

      <pre class="sourcecode">channel.basicPublish(<b>exchangeName</b>, <b>routingKey</b>,
             <b>new</b> AMQP.BasicProperties.Builder()
               .contentType("text/plain")
               .deliveryMode(2)
               .priority(1)
               .userId("bob")
               .build()),
               messageBodyBytes);</pre>

      <p>
        This example publishes a message with custom headers:
      </p>

      <pre class="sourcecode">Map&lt;String, Object&gt; headers = new HashMap&lt;String, Object&gt;();
headers.put("latitude",  51.5252949);
headers.put("longitude", -0.0905493);

channel.basicPublish(<b>exchangeName</b>, <b>routingKey</b>,
             <b>new</b> AMQP.BasicProperties.Builder()
               .headers(headers)
               .build()),
               messageBodyBytes);</pre>

      <p>
        This example publishes a message with expiration:
      </p>

      <pre class="sourcecode">channel.basicPublish(<b>exchangeName</b>, <b>routingKey</b>,
             <b>new</b> AMQP.BasicProperties.Builder()
               .expiration("60000")
               .build()),
               messageBodyBytes);</pre>

      <p>
        We have not illustrated all the possibilities here.
      </p>
      <p>
        Note that <span class="code ">BasicProperties</span> is an inner class of the autogenerated
        holder class <span class="code ">AMQP</span>.
      </p>

      <p>
        Invocations of <span class="code ">Channel#basicPublish</span> will eventually block if a
        <a href="http://www.rabbitmq.com/alarms.html">resource-driven alarm</a> is in effect.
      </p>
    </div>

    <div class="docSection"><a name="channel-threads" id="channel-threads"></a>
      <h2 class="docHeading">Channels and Concurrency Considerations (Thread Safety)</h2>

      <p>
        <span class="code ">Channel</span> instances must not be shared between
        threads. Applications
        should prefer using a <span class="code ">Channel</span> per thread
        instead of sharing the same <span class="code ">Channel</span> across
        multiple threads. While some operations on channels are safe to invoke
        concurrently, some are not and will result in incorrect frame interleaving
        on the wire. Sharing channels between threads will also interfere with
 * <a href="https://www.rabbitmq.com/confirms.html">Publisher Confirms</a>.
      </p>
    </div>

    <div class="docSection"><a name="consuming" id="consuming"></a>
      <h2 class="docHeading">Receiving messages by subscription</h2>

      <pre class="sourcecode"><b>import</b> com.rabbitmq.client.Consumer;
<b>import</b> com.rabbitmq.client.DefaultConsumer;</pre>

      <p>
        The most efficient way to receive messages is to set up a
        subscription using the <span class="code ">Consumer</span>
        interface. The messages will then be delivered
        automatically as they arrive, rather than having to be
        explicitly requested.
      </p>

      <p>
        When calling the API methods relating to
        <span class="code ">Consumer</span>s, individual subscriptions are
        always referred to by their consumer tags, which can be
        either client- or server-generated as explained in <a href="http://www.amqp.org/">the AMQP specification
        document</a>. Distinct <span class="code ">Consumer</span>s
        on the same <span class="code ">Channel</span> must have distinct consumer tags.
      </p>

      <p>
        The easiest way to implement a <span class="code ">Consumer</span> is to
        subclass the convenience class <span class="code ">DefaultConsumer</span>.
        An object of this subclass can be passed on a <span class="code ">basicConsume</span>
        call to set up the subscription:
      </p>

      <pre class="sourcecode"><b>boolean</b> autoAck = <b>false</b>;
channel.basicConsume(queueName, autoAck, "myConsumerTag",
     <b>new</b> DefaultConsumer(channel) {
         @Override
         <b>public</b> <b>void</b> handleDelivery(String consumerTag,
                                    Envelope envelope,
                                    AMQP.BasicProperties properties,
                                    <b>byte</b>[] body)
             <b>throws</b> IOException
         {
             String routingKey = envelope.getRoutingKey();
             String contentType = properties.getContentType();
             <b>long</b> deliveryTag = envelope.getDeliveryTag();
             <i>// (process the message components here ...)</i>
             channel.basicAck(deliveryTag, <b>false</b>);
         }
     });</pre>

      <p>
          Here, since we specified <span class="code ">autoAck = </span><b><span class="code ">false</span></b>,
          it is necessary to acknowledge messages delivered to the <span class="code ">Consumer</span>,
          most conveniently done in the <span class="code ">handleDelivery</span>
          method, as illustrated.
      </p>

      <p>
        More sophisticated <span class="code ">Consumer</span>s will need to override further
        methods.  In particular, <span class="code ">handleShutdownSignal</span>
        is called when channels and connections close, and
        <span class="code ">handleConsumeOk</span> is passed the consumer tag
        before any other callbacks to that <span class="code ">Consumer</span> are called.
      </p>

      <p>
        <span class="code ">Consumer</span>s can also implement the
        <span class="code ">handleCancelOk</span> and <span class="code ">handleCancel</span>
        methods to be notified of explicit and implicit cancellations,
        respectively.
      </p>

      <p>
        You can explicitly cancel a particular <span class="code ">Consumer</span> with
        <span class="code ">Channel.basicCancel</span>:
      </p>

      <pre class="sourcecode">channel.basicCancel(consumerTag);</pre>

      <p>
        passing the consumer tag.
      </p>
      <p>
        Callbacks to <span class="code ">Consumer</span>s are dispatched on a thread
        separate from the thread managed by the
        <span class="code ">Connection</span>. This means that
        <span class="code ">Consumer</span>s can safely call blocking methods on the
        <span class="code ">Connection</span> or <span class="code ">Channel</span>, such as
        <span class="code ">queueDeclare</span>, <span class="code ">txCommit</span>,
        <span class="code ">basicCancel</span> or <span class="code ">basicPublish</span>.
      </p>

      <p>
        Each <span class="code ">Channel</span> has its own dispatch thread. For the
        most common use case of one <span class="code ">Consumer</span> per
        <span class="code ">Channel</span>, this means <span class="code ">Consumer</span>s do
        not hold up other <span class="code ">Consumer</span>s. If you have multiple
        <span class="code ">Consumer</span>s per <span class="code ">Channel</span> be aware that
        a long-running <span class="code ">Consumer</span> may hold up dispatch of
        callbacks to other <span class="code ">Consumer</span>s on that
        <span class="code ">Channel</span>.
      </p>

    </div>

    <div class="docSection"><a name="getting" id="getting"></a>
      <h2 class="docHeading">Retrieving individual messages</h2>

      <p>
        To explicitly retrieve messages, use
        <span class="code ">Channel.basicGet</span>.  The returned value is an
        instance of <span class="code ">GetResponse</span>, from which the
        header information (properties) and message body can be
        extracted:
      </p>
<pre class="sourcecode"><b>boolean</b> autoAck = <b>false</b>;
GetResponse response = channel.basicGet(<b>queueName</b>, autoAck);
<b>if</b> (response == <b>null</b>) {
    <i>// No message retrieved.
</i>} <b>else</b> {
    AMQP.BasicProperties props = response.getProps();
    <b>byte</b>[] body = response.getBody();
    long deliveryTag = response.getEnvelope().getDeliveryTag();
    ...</pre>

      <p>
        and since the <span class="code ">autoAck</span> = <span class="code ">false</span> above,
        you must also call <span class="code ">Channel.basicAck</span> to
        acknowledge that you have successfully received the message:
      </p>
<pre class="sourcecode">    ...
    channel.basicAck(method.deliveryTag, <b>false</b>); <i>// acknowledge receipt of the message</i>
}</pre>

    </div>

    <div class="docSection"><a name="returning" id="returning"></a>
      <h2 class="docHeading">Handling unroutable messages</h2>

      <p>
        If a message is published with the "mandatory" flags set,
        but cannot be routed, the broker will return it to the
        sending client (via a <span class="code ">AMQP.Basic.Return</span>
        command).
      </p>
      <p>
        To be notified of such returns, clients can implement the <span class="code ">ReturnListener</span>
        interface and call <span class="code ">Channel.setReturnListener</span>.
        If the client has not configured a return listener for a particular channel,
        then the associated returned messages will be silently dropped.
      </p>

<pre class="sourcecode">channel.setReturnListener(<b>new</b> ReturnListener() {
    <b>public</b> <b>void</b> handleBasicReturn(int replyCode,
                                  String replyText,
                                  String exchange,
                                  String routingKey,
                                  AMQP.BasicProperties properties,
                                  byte[] body)
    <b>throws</b> IOException {
        ...
    }
});</pre>
      <p>
        A return listener will be called, for example, if the client publishes a message with
        the "mandatory" flag set to an exchange of "direct" type which is not bound to a queue.
      </p>
    </div>

      <div class="docSection"><a name="shutdown" id="shutdown"></a>
        <h2 class="docHeading">Shutdown Protocol</h2>
          <div class="docSubsection"><a name="shutdown-overview" id="shutdown-overview"></a>
        <h3 class="docHeading">Overview of the AMQP client shutdown</h3>
        <p>
          The AMQP 0-9-1 connection and channel share the same general
          approach to managing network failure, internal failure,
          and explicit local shutdown.
        </p>
        <p>
          The AMQP 0-9-1 connection and channel have the following lifecycle states:
        </p>
        <ul>
          <li>
        <span class="code ">open</span>: the object is ready to use
          </li>
          <li>
        <span class="code ">closing</span>: the object has been explicitly
        notified to shut down locally, has issued a shutdown
        request to any supporting lower-layer objects, and is
        waiting for their shutdown procedures to complete
          </li>
          <li>
        <span class="code ">closed</span>: the object has received all
        shutdown-complete notification(s) from any lower-layer
        objects, and as a consequence has shut itself down
          </li>
        </ul>
        <p>
          Those objects always end up in the closed state,
          regardless of the reason that caused the closure, like
          an application request, an internal client library
          failure, a remote network request or network failure.
        </p>
        <p>
          The AMQP connection and channel objects possess the
          following shutdown-related methods:
        </p>
        <ul>
          <li>
        <span class="code ">addShutdownListener(ShutdownListener
        listener)</span> and
        <span class="code ">removeShutdownListener(ShutdownListener
        listener)</span>, to manage any listeners, which will
        be fired when the object transitions to
        <span class="code ">closed</span> state. Note that, adding a
        ShutdownListener to an object that is already closed
        will fire the listener immediately
          </li>
          <li>
        <span class="code ">getCloseReason()</span>, to allow the
        investigation of what was the reason of the object’s
        shutdown
          </li>
          <li>
        <span class="code ">isOpen()</span>, useful for testing whether the
        object is in an open state
          </li>
          <li>
        <span class="code ">close(int closeCode, String
        closeMessage)</span>, to explictly notify the object
        to shut down
          </li>
        </ul>
        <p>
          Simple usage of listeners would look like:
        </p>
            <pre class="sourcecode"><b>import</b> com.rabbitmq.client.ShutdownSignalException;
<b>import</b> com.rabbitmq.client.ShutdownListener;

connection.addShutdownListener(<b>new</b> ShutdownListener() {
    <b>public void</b> shutdownCompleted(ShutdownSignalException cause)
    {
        ...
    }
});</pre>
      </div>
      <div class="docSubsection"><a name="shutdown-cause" id="shutdown-cause"></a>
        <h3 class="docHeading">Information about the circumstances of a shutdown</h3>
        <p>
          One can retrieve the
          <span class="code ">ShutdownSignalException</span>, which contains all
          the information available about the close reason, either
          by explictly calling the <span class="code ">getCloseReason()</span>
          method or by using the <span class="code ">cause</span> parameter in
          the <span class="code ">service(ShutdownSignalException cause)</span>
          method of the <span class="code ">ShutdownListener</span> class.
        </p>
        <p>
          The <span class="code ">ShutdownSignalException</span> class provides
          methods to analyze the reason of the shutdown. By
          calling the <span class="code ">isHardError()</span> method we get
          information whether it was a connection or a channel
          error, and <span class="code ">getReason()</span> returns information
          about the cause, in the form an AMQP method - either
          <span class="code ">AMQP.Channel.Close</span> or
          <span class="code ">AMQP.Connection.Close</span> (or null if the cause
          was some exception in the library, such as a network
          communication failure, in which case that exception can
          be retrieved with <span class="code ">getCause()</span>).
        </p>
            <pre class="sourcecode"><b>public void</b> shutdownCompleted(ShutdownSignalException cause)
{
  <b>if</b> (cause.isHardError())
  {
    Connection conn = (Connection)cause.getReference();
    <b>if</b> (!cause.isInitiatedByApplication())
    {
      Method reason = cause.getReason();
      ...
    }
    ...
  } <b>else</b> {
    Channel ch = (Channel)cause.getReference();
    ...
  }
}</pre>
          </div>
          <div class="docSubsection"><a name="shutdown-atomicity" id="shutdown-atomicity"></a>
            <h3 class="docHeading">Atomicity and use of the isOpen() method</h3>
            <p>
             Use of the <span class="code ">isOpen()</span> method of channel and
             connection objects is not recommended for production
             code, because the value returned by the method is
             dependent on the existence of the shutdown cause.  The
             following code illustrates the possibility of race
             conditions:
        </p>
        <pre class="sourcecode"><b>public void</b> brokenMethod(Channel channel)
{
    <b>if</b> (channel.isOpen())
    {
        // The following code depends on the channel being in open state.
        // However there is a possibility of the change in the channel state
        // between isOpen() and basicQos(1) call
        ...
        channel.basicQos(1);
    }
}</pre>
        <p>
          Instead, we should normally ignore such checking, and
          simply attempt the action desired. If during the
          execution of the code the channel of the connection is
          closed, a <span class="code ">ShutdownSignalException</span> will be
          thrown indicating that the object is in an invalid
          state. We should also catch for <span class="code ">IOException</span>
          caused either by <span class="code ">SocketException</span>, when
          broker closes the connection unexpectedly, or
          <span class="code ">ShutdownSignalException</span>, when broker
          initiated clean close.
        </p>
        <pre class="sourcecode"><b>public void</b> validMethod(Channel channel)
{
    <b>try</b> {
        ...
        channel.basicQos(1);
    } <b>catch</b> (ShutdownSignalException sse) {
        // possibly check if channel was closed
        // by the time we started action and reasons for
        // closing it
        ...
    } <b>catch</b> (IOException ioe) {
        // check why connection was closed
        ...
    }
}</pre>
          </div>
    </div>


<div class="docSection"><a name="advanced-connection" id="advanced-connection"></a>
  <h2 class="docHeading">Advanced Connection options</h2>
    <div class="docSubsection"><a name="consumer-thread-pool" id="consumer-thread-pool"></a>
        <h3 class="docHeading"><i>Consumer thread pool</i></h3>
        <p>
          <span class="code ">Consumer</span> threads (see <a href="#consuming">Receiving</a> below) are
          automatically allocated in a new <span class="code ">ExecutorService</span> thread pool
          by default. If greater control is required supply an <span class="code ">ExecutorService</span> on the
          <span class="code ">newConnection()</span> method, so that this pool of threads is
          used instead. Here is an example where a larger thread pool is
          supplied than is normally allocated:
</p><pre class="sourcecode">ExecutorService <b>es</b> = Executors.newFixedThreadPool(20);
Connection conn = factory.newConnection(<b>es</b>);
</pre>
          Both <span class="code ">Executors</span> and <span class="code ">ExecutorService</span> classes
          are in the <span class="code ">java.util.concurrent</span> package.
        <p></p>
        <p>
          When the connection is closed a default <span class="code ">ExecutorService</span>
          will be <span class="code ">shutdown()</span>, but a user-supplied
          <span class="code ">ExecutorService</span> (like <span class="code "><b>es</b></span> above) will
          <i>not</i> be <span class="code ">shutdown()</span>.
          Clients that supply a custom <span class="code ">ExecutorService</span> must ensure
          it is shutdown eventually (by calling its <span class="code ">shutdown()</span>
          method), or else the pool’s threads may prevent JVM termination.
        </p>
        <p>
          The same executor service may be shared between multiple connections,
          or serially re-used on re-connection but it cannot be used after it is
          <span class="code ">shutdown()</span>.
        </p>
        <p>
          Use of this feature should only be considered if there is evidence
          that there is a severe bottleneck in the processing of <span class="code ">Consumer</span>
          callbacks.
          If there are no <span class="code ">Consumer</span> callbacks executed, or very few, the default
          allocation is more than sufficient. The overhead is initially minimal and
          the total thread resources allocated are bounded, even if a burst of consumer
          activity may occasionally occur.
        </p>
    </div>

    <div class="docSubsection"><a name="address-array" id="address-array"></a>
        <h3 class="docHeading">Using Lists of Hosts</h3>
        <p>
          It is possible to pass an <span class="code ">Address</span> array
          to <span class="code ">newConnection()</span>.
          An <span class="code ">Address</span> is simply a convenience class
          in the <span class="code ">com.rabbitmq.client</span> package with <i>host</i>
          and <i>port</i> components.
          For example:
</p><pre class="sourcecode">Address[] addrArr = <b>new</b> Address[]{ <b>new</b> Address(hostname1, portnumber1)
                                 , <b>new</b> Address(hostname2, portnumber2)};
Connection conn = factory.newConnection(addrArr);
</pre>
          will attempt to connect to <span class="code ">hostname1:portnumber1</span>, and if
          that fails to <span class="code ">hostname2:portnumber2</span>. The connection returned is
          the first in the array that succeeds (without throwing
          <span class="code ">IOException</span>). This is entirely equivalent to repeatedly
          setting host and port on a factory, calling
          <span class="code ">factory.newConnection()</span> each time, until one of them succeeds.
        <p></p>
        <p>
          If an <span class="code ">ExecutorService</span> is provided as well (using the
          form <span class="code ">factory.newConnection(es, addrArr)</span>) the thread pool is
          associated with the (first) successful connection.
        </p>
    </div>


    <div class="docSubsection"><a name="heartbeats-timeout" id="heartbeats-timeout"></a>
        <h3 class="docHeading">Heartbeat Timeout</h3>
        <p>See the <a href="https://www.rabbitmq.com/heartbeats.html">Heartbeats guide</a> for more information about heartbeats
        and how to configure them in the Java client.</p>
    </div>

    <div class="docSubsection"><a name="thread-factories" id="thread-factories"></a>
      <h3 class="docHeading"><i>Custom Thread Factories</i></h3>
      <p>
        Environments such as Google App Engine (GAE) can <a href="https://developers.google.com/appengine/docs/java/#Java_The_sandbox">restrict
        direct thread instantiation</a>. To use RabbitMQ Java client in such environments,
        it's necessary to configure a custom <span class="code ">ThreadFactory</span> that uses
        an appropriate method to instantiate threads, e.g. GAE's <span class="code ">ThreadManager</span>.

        Below is an example for Google App Engine.
      </p>
      <p>
</p><pre class="sourcecode">import com.google.appengine.api.ThreadManager;

ConnectionFactory cf = new ConnectionFactory();
cf.setThreadFactory(ThreadManager.backgroundThreadFactory());
</pre>
      <p></p>
    </div>
</div>


    <div class="docSection"><a name="recovery" id="recovery"></a>
      <h2 class="docHeading">Automatic Recovery From Network Failures</h2>
      <div class="docSubsection"><a name="connection-recovery" id="connection-recovery"></a>
        <h3 class="docHeading">Connection Recovery</h3>
        <p>
          Network connection between clients and RabbitMQ nodes can fail.
          RabbitMQ Java client supports automatic recovery of connections
          and topology (queues, exchanges, bindings, and consumers).

          The automatic recovery process for many applications follows the following steps:
          </p><ol>
            <li>Reconnect</li>
            <li>Restore connection listeners</li>
            <li>Re-open channels</li>
            <li>Restore channel listeners</li>
            <li>Restore channel <span class="code ">basic.qos</span> setting, publisher confirms and transaction settings</li>
          </ol>

          Topology recovery includes the following actions, performed for every channel

          <ol>
            <li>Re-declare exchanges (except for predefined ones)</li>
            <li>Re-declare queues</li>
            <li>Recover all bindings</li>
            <li>Recover all consumers</li>
          </ol>

          To enable automatic connection recovery, use
          <span class="code ">factory.setAutomaticRecoveryEnabled(true)</span>:
          <pre class="sourcecode">ConnectionFactory factory = <b>new</b> ConnectionFactory();
factory.setUsername(<b>userName</b>);
factory.setPassword(<b>password</b>);
factory.setVirtualHost(<b>virtualHost</b>);
factory.setHost(<b>hostName</b>);
factory.setPort(<b>portNumber</b>);
factory.setAutomaticRecoveryEnabled(true);
// connection that will recover automatically
Connection conn = factory.newConnection();</pre>

          If recovery fails due to an exception (e.g. RabbitMQ node is
          still not reachable), it will be retried after a fixed time interval (default
          is 5 seconds). The interval can be configured:

          <pre class="sourcecode">ConnectionFactory factory = <b>new</b> ConnectionFactory();
// attempt recovery every 10 seconds
factory.setNetworkRecoveryInterval(10000);</pre>

          When a list of addresses is provided, the list is shuffled and
          all addresses are tried, one after the next:

          <pre class="sourcecode">ConnectionFactory factory = <b>new</b> ConnectionFactory();

Address[] addresses = {new Address("192.168.1.4"), new Address("192.168.1.5")};
factory.newConnection(addresses);</pre>
        <p></p>
      </div>

      <div class="docSubsection"><a name="recovery-listeners" id="recovery-listeners"></a>
        <h3 class="docHeading">Recovery Listeners</h3>
        <p>
          It is possible to register one or more recovery listeners on recoverable connections
          and channels. When connection recovery is enabled, connections returned by
          <span class="code ">ConnectionFactory#newConnection</span> and <span class="code ">Connection#createChannel</span>
          implement <span class="code ">com.rabbitmq.client.Recoverable</span>, providing two methods with
          fairly descriptive names:

          </p><ul>
            <li>addRecoveryListener</li>
            <li>removeRecoveryListener</li>
          </ul>

          Note that you currently need to cast connections and channels to <span class="code ">Recoverable</span>
          in order to use those methods.
        <p></p>
      </div>


      <div class="docSubsection"><a name="publishers" id="publishers"></a>
        <h3 class="docHeading">Effects on Publishing</h3>
        <p>
          Messages that are published using <span class="code ">Channel.basicPublish</span> when connection is down
          will be lost. The client does not enqueue them for delivery after connection has recovered.
          To ensure that published messages reach RabbitMQ applications need to use <a href="https://www.rabbitmq.com/confirms.html">Publisher Confirms</a>
          and account for connection failures.
        </p>
      </div>

      <div class="docSubsection"><a name="topology-recovery" id="topology-recovery"></a>
        <h3 class="docHeading">Topology Recovery</h3>
        <p>
          Topology recovery involves recovery of exchanges, queues, bindings
          and consumers. It is enabled by default but can be disabled:

          </p><pre class="sourcecode">ConnectionFactory factory = <b>new</b> ConnectionFactory();

Connection conn = factory.newConnection();
factory.setAutomaticRecoveryEnabled(true);
factory.setTopologyRecoveryEnabled(false);
          </pre>
        <p></p>
        </div>

      <div class="docSubsection"><a name="recovery-and-acknowledgements" id="recovery-and-acknowledgements"></a>
        <h3 class="docHeading">Manual Acknowledgements and Automatic Recovery</h3>
        <p>
          When manual acknowledgements are used, it is possible that
          network connection to RabbitMQ node fails between message
          delivery and acknowledgement. After connection recovery,
          RabbitMQ will reset delivery tags on all channels.

          This means that <i>basic.ack</i>, <i>basic.nack</i>, and <i>basic.reject</i>
          with old delivery tags will cause a channel exception. To avoid this,
          RabbitMQ Java client keeps track of and updates delivery tags to make them monotonically
          growing between recoveries.

          <span class="code ">Channel.basicAck</span>,
          <span class="code ">Channel.basicNack</span>, and
          <span class="code ">Channel.basicReject</span> then translate adjusted
          delivery tags into those used by RabbitMQ.

          <b>Acknowledgements with stale delivery tags will not be sent</b>. Applications
          that use manual acknowledgements and automatic recovery must
          be capable of handling redeliveries.
        </p>
      </div>
    </div>

    <div class="docSection"><a name="unhandled-exceptions" id="unhandled-exceptions"></a>
      <h2 class="docHeading">Unhandled Exceptions</h2>
      <p>
        Unhandled exceptions related to connection, channel, recovery,
        and consumer lifecycle are delegated to the exception
        handler. Exception handler is any object that implements the
        <span class="code ">ExceptionHandler</span> interface.  By default, an
        instance of <span class="code ">DefaultExceptionHandler</span> is used. It
        prints exception details to the standard output.
      </p>

      <p>
        It is possible to override the handler using
        <span class="code ">ConnectionFactory#setExceptionHandler</span>. It will be
        used for all connections created by the factory:

        </p><pre class="sourcecode">ConnectionFactory factory = <b>new</b> ConnectionFactory();
cf.setExceptionHandler(customHandler);
        </pre>

        Exception handlers should be used for exception logging.
      <p></p>
    </div>

    <div class="docSection"><a name="gae-pitfalls" id="gae-pitfalls"></a>
      <h2 class="docHeading">RabbitMQ Java Client on Google App Engine</h2>
      <p>
        Using RabbitMQ Java client on Google App Engine (GAE) requires using a custom
        thread factory that instantiates thread using GAE's <span class="code ">ThreadManager</span> (see above).
        In addition, it is necessary to set a low heartbeat interval (4-5 seconds) to avoid running
        into the low <span class="code ">InputStream</span> read timeouts on GAE:

        </p><pre class="sourcecode">ConnectionFactory factory = <b>new</b> ConnectionFactory();
cf.setRequestedHeartbeat(5);
        </pre>
      <p></p>
    </div>

    <div class="docSection"><a name="cache-pitfalls" id="cache-pitfalls"></a>
      <h2 class="docHeading">Caveats and Limitations</h2>
      <p>
        To make topology recovery possible, RabbitMQ Java client maintains a cache
        of declared queues, exchanges, and bindings. The cache is per-connection. Certain
        RabbitMQ features make it impossible for clients to observe some topology changes,
        e.g. when a queue is deleted due to TTL. RabbitMQ Java client tries to invalidate
        cache entries in the most common cases:

        </p><ul>
          <li>When queue is deleted.</li>
          <li>When exchange is deleted.</li>
          <li>When binding is deleted.</li>
          <li>When consumer is cancelled on an auto-deleted queue.</li>
          <li>When queue or exchange is is unbound from an auto-deleted exchange.</li>
        </ul>

        However, the client cannot track these topology changes beyond a single connection.
        Applications that rely on auto-delete queues or exchanges, as well as queue TTL (note: not message TTL!),
        and use automatic connection recovery, should explicitly delete entities know to be unused
        or deleted, to purge client-side topology cache. This is facilitated by <span class="code ">Channel#queueDelete</span>,
        <span class="code ">Channel#exchangeDelete</span>, <span class="code ">Channel#queueUnbind</span>, and <span class="code ">Channel#exchangeUnbind</span>
        being idempotent in RabbitMQ 3.3.x (deleting what's not there does not result in an exception).
      <p></p>
    </div>


      <div class="docSection"><a name="rpc" id="rpc"></a>
    <h2 class="docHeading">The RPC (Request/Reply) Pattern</h2>

    <p>
      As a programming convenience, the Java client API offers a
      class <span class="code ">RpcClient</span> which uses a temporary reply
      queue to provide simple <a href="https://www.rabbitmq.com/tutorials/tutorial-six-java.html">RPC-style communication</a> facilities via AMQP 0-9-1.
    </p>
    <p>
      The class doesn’t impose any particular format on the RPC arguments and return values.
      It simply provides a mechanism for sending a message to a given exchange with a particular
      routing key, and waiting for a response on a reply queue.
    </p>

    <pre class="sourcecode"><b>import</b> com.rabbitmq.client.RpcClient;

RpcClient rpc = <b>new</b> RpcClient(<b>channel</b>, <b>exchangeName</b>, <b>routingKey</b>);</pre>

    <p>
      (The implementation details of how this class uses AMQP 0-9-1 are as follows: request messages are sent with the
      <span class="code ">basic.correlation_id</span> field set to a value unique for this <span class="code ">RpcClient</span> instance,
      and with <span class="code ">basic.reply_to</span> set to the name of the reply queue.)
    </p>

    <p>
      Once you have created an instance of this class, you can use it to
 send RPC requests by using any of the following methods:
    </p>

    <pre class="sourcecode"><b>byte</b>[] primitiveCall(<b>byte</b>[] message);
String stringCall(String message)
Map mapCall(Map message)
Map mapCall(Object[] keyValuePairs)</pre>

    <p>
      The <span class="code ">primitiveCall</span> method transfers raw byte arrays as the request and response
      bodies. The method <span class="code ">stringCall</span> is a thin
      convenience wrapper around <span class="code ">primitiveCall</span>,
      treating the message bodies as <span class="code ">String</span> instances
      in the default character encoding.
    </p>
    <p>
      The <span class="code ">mapCall</span> variants are a little more sophisticated: they encode
      a <span class="code ">java.util.Map</span> containing ordinary Java values
      into an AMQP 0-9-1 binary table representation, and decode the
      response in the same way. (Note that there are some restrictions on what value
      types can be used here - see the javadoc for details.)
    </p>

    <p>
      All the marshalling/unmarshalling convenience methods use <span class="code ">primitiveCall</span> as a
      transport mechanism, and just provide a wrapping layer on top of it.
    </p>
      </div>

  </div><div id="right-nav"><div id="in-this-section"><h4>In This Section</h4><ul>
     <li><a href="https://www.rabbitmq.com/admin-guide.html">Server Documentation</a></li>
     <li><a href="https://www.rabbitmq.com/clients.html" class="selected">Client Documentation</a><ul>
       <li><a href="https://www.rabbitmq.com/api-guide.html" class="selected">Java Client Guide</a><ul>
         <li><a href="https://www.rabbitmq.com/java-tools.html">Java Client Tools</a></li>
         
       </ul></li>
       <li><a href="https://www.rabbitmq.com/dotnet-api-guide.html">.NET Client Guide</a></li>
       <li><a href="https://www.rabbitmq.com/heartbeats.html">Heartbeats</a></li>
       <li><a href="https://www.rabbitmq.com/erlang-client-user-guide.html">Erlang Client Guide</a></li>
       <li><a href="https://www.rabbitmq.com/uri-spec.html">AMQP URI Spec</a></li>
       
       
       
       
     </ul></li>
     <li><a href="https://www.rabbitmq.com/plugins.html">Plugins</a></li>
     <li><a href="https://www.rabbitmq.com/news.html">News</a></li>
     <li><a href="https://www.rabbitmq.com/protocol.html">Protocol</a></li>
     <li><a href="https://www.rabbitmq.com/extensions.html">Our Extensions</a></li>
     <li><a href="https://www.rabbitmq.com/build.html">Building</a></li>
     
       <li><a href="https://www.rabbitmq.com/previous.html">Previous Releases</a></li>
     
     <li><a href="https://www.rabbitmq.com/mpl.html">License</a></li>
   </ul></div><div class="in-this-page"><h4>In This Page</h4><ul><li><a href="#classoverview">Overview</a></li><li><a href="#connecting">Connections and Channels</a></li><li><a href="#exchanges-and-queues">Using Exchanges and Queues</a></li><li><a href="#publishing">Publishing messages</a></li><li><a href="#channel-threads">Channels and Concurrency Considerations (Thread Safety)</a></li><li><a href="#consuming">Receiving messages by subscription</a></li><li><a href="#getting">Retrieving individual messages</a></li><li><a href="#returning">Handling unroutable messages</a></li><li><a href="#shutdown">Shutdown Protocol</a></li><li><a href="#advanced-connection">Advanced Connection options</a></li><li><a href="#recovery">Automatic Recovery From Network Failures</a></li><li><a href="#unhandled-exceptions">Unhandled Exceptions</a></li><li><a href="#gae-pitfalls">RabbitMQ Java Client on Google App Engine</a></li><li><a href="#cache-pitfalls">Caveats and Limitations</a></li><li><a href="#rpc">The RPC (Request/Reply) Pattern</a></li></ul></div><div id="related-links"><h4>Related Links</h4><ul><li><a href="https://www.rabbitmq.com/java-client.html">Java Client Downloads</a></li></ul></div></div><div class="clear"></div><div class="pageFooter"><p class="righter"><a href="https://www.rabbitmq.com/sitemap.html">Sitemap</a> |
        <a href="https://www.rabbitmq.com/contact.html">Contact</a></p><p id="copyright">
        Copyright © 2007-2016 Pivotal Software, Inc. All rights reserved
        |&nbsp;<a href="http://pivotal.io/privacy-policy">Privacy Policy</a>
        |&nbsp;<a href="https://github.com/rabbitmq/rabbitmq-website/">This Site is Open Source</a>
        |&nbsp;<a href="http://pivotal.io/careers/engineering">Pivotal is Hiring</a></p></div></div>

</body></html>